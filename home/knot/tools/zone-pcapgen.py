#!/usr/bin/env python
import sys, getopt
from scapy.all import *
from pydig import Tsig
domain = ''
dbfile = ''
target = '127.0.0.1'
target_port = 53
eaddr = '00:00:00:00:00'
tsname = 'key'
tskey = 'Wg=='

# Usage
def usage():
	print "%s: [-h] [-t TARGET] [-p PORT] <domain> <typedb>" % sys.argv[0]
	print "Parameters:"
	print "\t-h\tHelp."
	print "\t-t TARGET\tTarget DNS server (%s)." % "127.0.0.1"
	print "\t-p PORT\tTarget DNS server port (%d)." % 53531
	print "\t-y name:key\tTSIG name and key, key in base64 ('%s':'%s')." % (tsname, tskey)
	print "\t<typedb> may be generated by zone-typelist.sh"
	print "\t         format: 'name TYPE\n'"

# Parse options
try:
	opts, args = getopt.getopt(sys.argv[1:], "ht:p:y:", [])
except getopt.GetoptError, err:
	usage()
	sys.exit(1)
for o, a in opts:
	if o == '-h':
		usage()
		sys.exit(1)
	elif o == '-t':
		target = a
	elif o == '-p':
		target_port = int(a)
	elif o == '-y':
		a = a.split(':')
		if len(a) != 2:
			usage()
			sys.exit(2)
		tsname = a[0]
		tskey = a[1]
	else:
		usage()
		sys.exit(1)

# Check options
ts = Tsig()
tskey = tskey.decode('base64')
if not tsname.endswith('.'):
	tsname += '.'
ts.setkey(tsname, tskey)

# Arguments
if len(args) > 2:
	print 'Too many arguments, for help use --help'
	sys.exit(2)
if len(args) < 2:
	print 'Too few arguments, for help use --help'
	sys.exit(2)
for a in args:
	if len(domain) == 0:
		if a != '.':
			a = a.rstrip('.')
		domain = a
	else:
		dbfile = a

# Overview
print "# Zone '%s', type database '%s'" % (domain, dbfile)
print "# Target host %s@%d" % (target, target_port)

# Read type db
fd = open(dbfile)
types = {}
for l in fd:
	l = l.strip().split(' ')	
	types[l[1]] = l[0]
fd.close()

# Create list of packets
PKTS = []
qrbase = Ether(dst=eaddr,src=eaddr)/IP(dst=target)/UDP(sport=RandShort(),dport=target_port)

# Add query
def aq(x):
	PKTS.append(Ether(dst=eaddr,src=eaddr)/IP(dst=target)/UDP(sport=RandShort(),dport=target_port)/x)

# TSIG query
def tq(x):
	tsig_rr = DNSRR(ts.mk_request_tsig(len(PKTS), str(x)))
	x.arcount += 1
	x.ar = tsig_rr
	return aq(x)

# TSIG RR
def tsig_rr(x):
	return DNSRR(ts.mk_request_tsig(len(PKTS), str(x)))
	
# 1. Queries to existing names
typelist = types.items()
print '%d..%d queries to existing names' % (len(PKTS), len(PKTS)+len(typelist))
for k,v in typelist:
	aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname=v,qtype=k)))

# 2. Queries to nonmatching name-type
print '%d..%d queries to non-matching (name - type)' % (len(PKTS), len(PKTS)+len(typelist))
i = 0
for k,v in typelist: 
	t = typelist[(i+1) % len(typelist)][0]
	i += 1
	aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname=v,qtype=t)))

# 3. Queries to non-existing names
print '%d..%d queries to non-existing names' % (len(PKTS), len(PKTS)+len(typelist))
for k,v in typelist:
	v = 'invalid-prefix.' + v
	aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname=v,qtype=k)))

# 4. Queries to names out of zone
print '%d..%d queries to names out of zone' % (len(PKTS), len(PKTS)+len(typelist))
for k,v in typelist:
        v = v + 'out-of-zone.'
        aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname=v,qtype=k)))

# 5. Varying case
print '%d..%d queries to names with swapped case' % (len(PKTS), len(PKTS)+len(typelist))
for k,v in typelist:
	v = v.swapcase()
	aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname=v,qtype=k)))

# 6. All opcodes + RD set/unset
(k, v) = typelist[0]
print '%d..%d queries with 16 opcodes, \'%s\' type, RD flag 0/1' % (len(PKTS), len(PKTS)+16*2, k)
ops = xrange(0, 15+1)
for rrd in xrange(0, 1+1):
	for i in ops:
		aq(DNS(id=len(PKTS),opcode=i,rd=rrd,qdcount=1,qd=DNSQR(qname=v,qtype=k)))

# 7. Artificial numbers in QD/AN/NS/AR
ab = 0
ae = 3
print '%d..%d queries to artificial numbers in QD/AN/NS/AR counts' % (len(PKTS), len(PKTS)+(ae-ab+1)**4)
for qd in xrange(ab,ae+1):
	for an in xrange(ab, ae+1):
		for ns in xrange(ab, ae+1):
			for ar in xrange(ab, ae+1):
				aq(DNS(id=len(PKTS),qdcount=qd,ancount=an,nscount=ns,arcount=ar,qd=DNSQR(qname=v,qtype=k)))
# 8. Varying number of questions
qdlist = range(0,65+1,16)
print '%d..%d queries to with multiple questions' % (len(PKTS), len(PKTS)+len(qdlist))
for i in qdlist:
	qds = DNSQR(qname='%d.%d-%s' % (i,0,v),qtype=k)
	for j in xrange(1, i+1):
		qn = '%d.%d-%s' % (i,j,v)
		qds = qds/DNSQR(qname=qn,qtype=k)
	aq(DNS(id=len(PKTS),qdcount=i,qd=qds))

# 9. EDNS0 + DNSSEC for existing & non-existing names
# Scapy doesn't support DNSSEC yet, OPT RR written according to http://tools.ietf.org/html/rfc2671
print '%d..%d queries to existing/different type/non-existing names with EDNS0' % (len(PKTS), len(PKTS)+4)
print '%d..%d queries to existing/different type/non-existing names with DNSSEC' % (len(PKTS)+3, len(PKTS)+4+4)
for i in (0x00000000, 0x00008000): # EDNS0, DO bit set
	# Existing name & type
	aq(DNS(id=len(PKTS),qdcount=1,arcount=1,qd=DNSQR(qname=v,qtype=k),ar=DNSRR(type=41,rclass=8192,ttl=i)))
	# Existing name & different type
	kk = typelist[len(typelist)-1][0]
	aq(DNS(id=len(PKTS),qdcount=1,arcount=1,qd=DNSQR(qname=v,qtype=kk),ar=DNSRR(type=41,rclass=8192,ttl=i)))
	# Non-existing name
	vv = 'invalid-prefix.' + v
	aq(DNS(id=len(PKTS),qdcount=1,arcount=1,qd=DNSQR(qname=vv,qtype=k),ar=DNSRR(type=41,rclass=8192,ttl=i)))
	# Out-of-zone name
	vv = v + 'out-of-zone.'
	aq(DNS(id=len(PKTS),qdcount=1,arcount=1,qd=DNSQR(qname=vv,qtype=k),ar=DNSRR(type=41,rclass=8192,ttl=i)))
	

# 10. NSID RFC5001
# Scapy doesn't support NSID yet, OPT RR written in raw
# http://www.ietf.org/rfc/rfc5001.txt
print '%d..%d queries with NSID' % (len(PKTS), len(PKTS)+1)
aq(DNS(id=len(PKTS),qdcount=1,arcount=1,qd=DNSQR(qname=v,qtype=k),ar=DNSRR(type=41,rclass=8192,ttl=0,rdlen=4,rdata='\x00\x03\x00\x00')))

# 11. Varying RCLASS
rcrange = range(0,5+1) + [254,255]
print '%d..%d queries with rclass = <0,5> NONE, ANY' % (len(PKTS), len(PKTS)+len(rcrange))
for i in rcrange:
        aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname=v,qtype=k,qclass=i)))

# 12. TC bit set
print '%d..%d queries with TC bit set' % (len(PKTS), len(PKTS)+1)
aq(DNS(id=len(PKTS),qdcount=1,tc=1,qd=DNSQR(qname=v,qtype=k)))

# 13. AA bit set
print '%d..%d queries with AA bit set' % (len(PKTS), len(PKTS)+1)
aq(DNS(id=len(PKTS),qdcount=1,aa=1,qd=DNSQR(qname=v,qtype=k)))

# 14. SOA queries
print '%d..%d queries for SOA' % (len(PKTS), len(PKTS)+3)
aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname=v,qtype='SOA')))
aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname='invalid-prefix.' + v,qtype='SOA')))
aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname=v + 'out-of-zone.',qtype='SOA')))

# 15. CH queries
print '%d..%d queries for CH zones' % (len(PKTS), len(PKTS)+3)
aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname='version.bind',qtype='TXT',qclass='CH')))
aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname='hostname.bind',qtype='TXT',qclass='CH')))
aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname='version.server',qtype='TXT',qclass='CH')))

# 16. Invalid character in dname
#print '%d..%d queries with invalid characters in dnames' % (len(PKTS), len(PKTS)+2)
aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname='\x00' + v,qtype=k)))
aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname=v + '\xff',qtype=k)))

# 17. TSIG
# @TODO only hmac-md5 is supported
print '%d..%d queries with TSIG ([in]valid name/key/fudge and name/type variations)' % \
(len(PKTS), len(PKTS)+(len(typelist) * 4 * 2 * 2 * 2))
i = 0
for k,v in typelist:
	for tn in (tsname, 'invalid' + tsname):
		for tk in (tskey, 'invalid' + tskey):
			for fudge in (0, 300):
				ts.setkey(tn, tk)
				ts.request.fudge = fudge
				t = typelist[(++i) % len(typelist)][0]
				tq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname=v,qtype=k)))
				tq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname=v,qtype=t)))
				tq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname='invalid-prefix.' + v,qtype=k)))
				tq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname=v + 'out-of-zone.',qtype=k)))
ts.setkey(tsname, tskey)
ts.request.fudge = 300


# 17. TSIG - misplaced
print '%d..%d queries with misplaced TSIG' % \
(len(PKTS), len(PKTS)+6)
k,v = typelist[0]
bq = DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname=v,qtype=k))
q = bq; q.arcount = 2; q.ar = tsig_rr(q)/DNSRR(type='TXT',rrname='somename'); aq(q) # TSIG, TXT
q = bq; q.arcount = 2; q.ar = tsig_rr(q)/DNSRR(type=41); aq(q) # TSIG,OPT
q = bq; q.arcount = 2; q.ar = DNSRR(type=250)/DNSRR(type=250); aq(q) # TSIG,TSIG (empty)
q = bq; q.arcount = 2; q.ar = DNSRR(type=41)/DNSRR(type=250); aq(q) # OPT,TSIG (empty)
q = bq; q.arcount = 2; q.ar = DNSRR(type=41)/DNSRR(type=41); aq(q) # OPT,OPT (empty)
q = bq; q.nscount = 1; q.ns = tsig_rr(q); aq(q) # TSIG in NS

# 18. CNAME not exists
print '%d..%d queries to CNAME pointing to existing/nonexisting record' % (len(PKTS), len(PKTS)+3)
qn="cn-notexists." + domain
aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname=qn,qtype='A')))
aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname=qn + '.ooz',qtype='A')))

# 19. Arbitrary NSEC3 tests
print '%d..%d arbitrary NSEC3+CNAME tests' % (len(PKTS), len(PKTS)+6+1)
for i in xrange(1,6):
        qn = 'a.nsec3-test%d.%s' % (i, domain)
        qt = 'A'
        aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname=qn,qtype=qt)));
qn = 'nsec3-test4.%s' % domain
qt = 'A'
aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname=qn,qtype=qt)));
aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname='wc001.%s' % domain, qtype='A')));

# 20. Arbitrary DNAME tests
print '%d..%d arbitrary DNAME tests' % (len(PKTS), len(PKTS)+4)
aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname='dname-t0.dname-t0.%s' % domain, qtype='A')));
aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname='dname-t0.dname-t0.%s' % domain, qtype='MX')));
aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname='dname-t0.dname-t2.%s' % domain, qtype='A')));
aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname='dname-t2.%s' % domain, qtype='A')));

# 21. Arbitrary wildcard-covered address in RDATA
print '%d..%d arbitrary wildcard-in-rdata tests' % (len(PKTS), len(PKTS)+5)
aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname='ns-wrr.%s' % domain, qtype='NS')));
aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname='mx-wrr.%s' % domain, qtype='MX')));
aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname='ptr-wrr.%s' % domain, qtype='PTR')));
aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname='afsdb-wrr.%s' % domain, qtype='AFSDB')));
aq(DNS(id=len(PKTS),qdcount=1,qd=DNSQR(qname='_sip._tcp.srv-wrr.%s' % domain, qtype='SRV')));

# Dump to pcap
print '==='
pcap_out = domain + '.pcap'
print '%d queries total, saving to \'%s\'' % (len(PKTS), pcap_out)
wrpcap(pcap_out,  PKTS)
